# OS 第九次作业

12.2  Suppose that a disk drive has 5,000 cylinders, numbered 0 to 4999. The drive is currently serving a request at cylinder 143, and the previous request was at cylinder 125. The queue of pending requests, in FIFO order, is:

​     86,1470,913,1774,948,1509,1022,1750,130

  Starting from the current head position, what is the total distance (in cylinders) that the disk arm moves to satisfy all the pending requests for each of the following disk-scheduling algorithms?

a.    FCFS

b.    SSTF

c.     SCAN

d.    LOOK

e.    C-SCAN

f.     C-LOOK

解：**a.FCFS**

按照请求队列的顺序处理请求： 143→86→1470→913→1774→948→1509→1022→1750→130

计算移动距离：     ∣143−86∣+∣86−1470∣+∣1470−913∣+∣913−1774∣+∣1774−948∣+∣948−1509∣+∣1509−1022∣+∣1022−1750∣+∣1750−130∣ 

=57+1384+557+861+826+561+487+728+1620 

=7081

 **b.SSTF**

每次选择当前磁头位置最近的未处理请求：
143 → 130 → 86 → 913 → 948→ 1022→ 1470 → 1509 → 1750→ 1774

计算各段距离：

143→130: 13

130→86: 44

86→913: 827

913→948: 35

948→1022: 74

1022→1470: 448

1470→1509: 39

1509→1750: 241

1750→1774: 24

**总距离**：13 + 44 + 827 + 35 + 74 + 448 + 39 + 241 + 24 = 1745

**c. SCAN**

处理顺序：向右处理≥143 的请求（升序），到 4999 后向左处理 < 143 的请求（降序）： 

143 → 913 → 948 → 1022 → 1470 → 1509 → 1750 → 1774 → 4999 → 130 → 86 

计算各段距离：

143→913: 770

913→948: 35

948→1022: 74

1022→1470: 448

1470→1509: 39

1509→1750: 241

1750→1774: 24

1774→4999: 3225

4999→130: 4869

130→86: 44 

**总距离**：770 + 35 + 74 + 448 + 39 + 241 + 24 + 3225 + 4869 + 44 = 9769

**d. LOOK**

处理顺序：向右到最远请求 1774（升序），向左到最近请求 86（降序）：

143 → 913 → 948 → 1022 → 1470 → 1509 → 1750 → 1774 → 130 → 86 

计算各段距离：

143→913: 770

913→948: 35

948→1022: 74

1022→1470: 448

1470→1509: 39

1509→1750: 241

1750→1774: 24

1774→130: 1644

130→86: 44 

**总距离**：770 + 35 + 74 + 448 + 39 + 241 + 24 + 1644 + 44 = 3319

**e. C-SCAN**

处理顺序：向右到 4999（升序处理≥143 的请求），跳转至 0，向右处理 < 143 的请求（升序）：

 143 → 913 → 948 → 1022 → 1470 → 1509 → 1750 → 1774 → 4999（跳转至 0） → 86 → 130 

计算有效移动距离：

143→913: 770

913→948: 35

948→1022: 74

1022→1470: 448

1470→1509: 39

1509→1750: 241

1750→1774: 24

1774→4999: 3225

0→86: 86

86→130: 44 

**总距离**：770 + 35 + 74 + 448 + 39 + 241 + 24 + 3225 + 86 + 44 = 4986

**f. C-LOOK**

处理顺序：向右到最远请求 1774（升序），跳转至最小请求 86，向右处理剩余请求（升序）： 

143 → 913 → 948 → 1022 → 1470 → 1509 → 1750 → 1774（跳转至 86） → 86 → 130 

计算有效移动距离：

143→913: 770

913→948: 35

948→1022: 74

1022→1470: 448

1470→1509: 39

1509→1750: 241

1750→1774: 24

86→130: 44 

**总距离**：770 + 35 + 74 + 448 + 39 + 241 + 24 + 44 = 1675

|  算法  | 总距离（柱面） |
| :----: | :------------: |
|  FCFS  |      7081      |
|  SSTF  |      1745      |
|  SCAN  |      9769      |
|  LOOK  |      3319      |
| C-SCAN |      4986      |
| C-LOOK |      1675      |

####  13章  I/O系统

1. 什么是设备独立性？ 为什么要引入设备独立性？如何实现设备独立性？

   设备独立性指应用程序不依赖于具体物理设备，以统一方式访问不同设备。

   目的是为了提高操作系统的可适应性和可扩展性。

   实现设备独立性的核心是通过逻辑设备表（LUT）将应用程序使用的逻辑设备名映射为系统管理的物理设备名，具体方式如下： 1. 引入逻辑/物理设备概念：应用程序仅通过逻辑名称请求设备，不涉及物理细节。 2. 建立映射机制：通过LUT实现逻辑到物理名称的转换，屏蔽设备差异。 3. LUT设置策略    单用户系统：全局共享一张LUT，统一管理所有设备映射。多用户系统：为每个用户独立配置LUT，实现个性化设备分配。 通过这种分层抽象，系统可灵活调度物理设备，应用程序无需关心具体实现，从而达成设备独立性。

2. 简述SPOOLing技术。

   SPOOLing技术是将独占设备转换为共享设备的有效技术，具体如下： 

   技术背景：在批处理操作系统时代引入，即假脱机输入/输出技术。 

   技术概念：利用多道程序中的程序分别模拟脱机输入、输出时外围控制机功能，在主机控制下实现脱机输入、输出，使外围操作和CPU处理数据能同时进行。

   系统组成：需高速随机外存（如磁盘），由输入井和输出井、输入缓冲和输出缓冲、输入进程和输出进程组成。    

   实现方式：以打印机为例，用户进程请求打印时，输出进程在输出井申请空闲盘块区存放打印数据，申请空白用户请求打印表并挂到请求打印队列，输出进程按表将数据从输出井传至内存缓冲区，再由打印机打印。

   技术特点：提高I/O速度，将独占设备改造为共享设备，实现虚拟设备功能。 

3. 设备驱动程序要完成哪些工作？

   将抽象要求转换为具体要求→检查I/O请求的合法性→读出和检查设备的状态→传送必要的参数→方式的设置→启动I/O设备